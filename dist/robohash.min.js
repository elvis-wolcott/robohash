class Robohash{constructor(s){const t=(s,t)=>s&&s.length===t?r:0;this.colors=t(s.foreground,10)||["#ff9800","#E53935","#FDD835","#2745C4","#03a9f4","#9c27b0","#11A387","#EA2D75","#82C11F","#913C29"],this.bgColors=t(s.background,10)||["#58DDB1","#58DDB1","#EB8DFF","#FF9E80","#FF8A80","#FFD869","#FF8A80","#8c9eff","#FF9E80","#88E9FF"],this.matchColors=void 0===s.matchColors?0:s.matchColors?0:1,this.path=s.path||""}svg(s){const t=this._hash(s);return this._svgTemplate(this.colors[t[0]],this.bgColors[t[this.matchColors]],t[2],t[3],t[4],t[5],t[6])}render(s,t){t.innerHTML=this.svg(s)}toDataUrl(s){return`data:image/svg+xml;base64,${btoa(this.svg(s))}`}_svgTemplate(s,t,h,e,r,o,a){return this._$svg(this._$robohash(s,t,h,e,r,o,a))}_clippedsvgTemplate(s,t,h,e,r,o,a){return this._$svg(this._$robohash(s,t,h,e,r,o,a))}_$robohash(s,t,h,e,r,o,a){return`\n            <g style="color:${s}">\n                <rect fill="${t}" x="0" y="0" width="320" height="320"></rect>\n                ${this._$use("body",h)}\n                ${this._$use("face",e)}\n                ${this._$use("eyes",r)}\n                ${this._$use("mouth",o)}\n                ${this._$use("accessory",a)}\n            </g>`}_$svg(s){return`\n            <svg viewBox="0 0 320 320" width="320" height="320" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/2000/xlink" >\n                ${s}\n            </svg>`}_$use(s,t){return`<use width="320" height="300" transform="translate(0,20)" xlink:href="${this.path}/robohash.min.svg#${s}-${this._assetIndex(t)}" />`}_assetIndex(s){return(s=Number(s)+1)<10?"0"+s:s}_hash(s){return(""+s.split("").map(s=>Number(s.charCodeAt(0))+3).reduce((s,t)=>s*(1-s)*this.__chaosHash(t),.5)).split("").reduce((s,t)=>t+s,"").substr(4,10)}__chaosHash(s){let t=1/s;for(let s=0;s<100;s++)t=(1-t)*t*3.569956786876;return t}}export default Robohash;export{Robohash};